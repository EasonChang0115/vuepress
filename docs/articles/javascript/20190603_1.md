---
title: Javascript 建立物件的方式
category: Javascript
tags:
  - Javascript
  - object
description: Javascript 是一種物件導向的語言，可以用 OOP 的概念來撰寫程式。但真正的類別概念卻與其他物件導向的語言有所差別，這也跟我前一篇所講 javascript 繼承與其他程式語言不同有異曲同工之妙。前一篇講到了原型物件、繼承的關係及建構函數等等觀念。這篇就來講如何在 javascript 如何創造物件原型，而這些物件原型都可以用 New 運算子來建立一個新物件信，新物件的\_\_proro\_\_指向物件原型。
image: https://i.imgur.com/LYBvhdF.png
meta:
  - name: og:url
    content: https://easonchang0115.github.io/articles/javascript/20190516_1.html
  - name: og:title
    content: Javascript 建立物件的方式
  - name: og:description
    content: Javascript 是一種物件導向的語言，可以用 OOP 的概念來撰寫程式。但真正的類別概念卻與其他物件導向的語言有所差別，這也跟我前一篇所講 javascript 繼承與其他程式語言不同有異曲同工之妙。前一篇講到了原型物件、繼承的關係及建構函數等等觀念。這篇就來講如何在 javascript 如何創造物件原型，而這些物件原型都可以用 New 運算子來建立一個新物件信，新物件的\_\_proro\_\_指向物件原型。
  - name: og:image
    content: https://easonchang0115.github.io/20190514_1.png
gitTalk: true
---

Javascript 是一種物件導向的語言，可以用 OOP 的概念來撰寫程式。但真正的類別概念卻與其他物件導向的語言有所差別，這也跟我前一篇所講 javascript 繼承與其他程式語言不同有異曲同工之妙。前一篇講到了原型物件、繼承的關係及建構函數等等觀念。這篇就來講如何在 javascript 如何創造物件原型，而這些物件原型都可以用 New 運算子來建立一個新物件信，新物件的\_\_proro\_\_指向物件原型。

<!-- more -->

# Javascript 建立物件的方式

我們都可以使用 new 運算子來建立新物件，而物件原型在 javascript 有很多不同的建立方式，用基本函數建立或到現在比較常用的 class (語法糖)等，都是原型鍊的概念來實現繼承等等。漸漸的 javacript 也可以像是其他語言的開發模式般使用 OOP 的方式來實現物件的繼承、建構等等，這邊整理幾個常見的建立物件原型的方式。

## 直接用大括號對建立物件

優點：這種方式其實是最直覺的方式，可以知道該物件有什麼可以用的屬性及方法。

缺點：我不們可能用這樣的方式大量的建立物件，這樣不僅不好維護也不好去重複利用。

```js
let person = {
  name: 'Eason',
  sayHi: function () {
    console.log('Hi! I am ' + this.name);
  }
}

console.log(person.name);  // Eason
person.sayHi(); // Hi! I am Eason 
```

## 函數回傳新的物件

也有人說是工廠模式，函數就像工廠一樣，送進去需要的變數，回傳所需的新物件，可以重複利用。

優點：很好的利用函數來實現封裝，可以無數次調用該函數來建立新物件。

缺點：該方式有點不直覺，而且產生的新物件原型都指向 Object，無法再進一步做判斷該物件的類別。(無法通過 constructor 或者 instanceof 來判斷物件的原型)

```js
function createPerson(name, job) {
  let o = new Object()
  o.name = name;
  o.job = job;
  o.sayHi = function() {
    console.log('Hi! I am ' + this.name);
  };
  return o;
}
let person1 = createPerson('Amber', 'Nurse');
let person2 = createPerson('Eason', 'Engineer');
```

:::tip
以上兩種方式建立的物件，他們的 \_\_proto\_\_ 都指向最原始的物件 Object，所以我們沒有辦法透過建構函數去判斷該物件是屬於那一個原型建立的。
:::

## 建構函數

函數為一等公民，可以指定給另一個變數、當作參數、作為回傳值等，也可以把函數當做建構子來使用並用 New 運算子來產生新的物件。

1. 創造一個新物件 Object。
2. 執行建構函數，並把裡面的 this 指向新的物件。
3. 新物件的 \_\_proto\_\_ 指向 Person 來繼承 Person 的 prototype。
4. 回傳新物件。

優點：從第三步就可以知道，我們可以用 constructor 或者 instanceof 來判斷物件的原型。

缺點：有一個小小的缺點就是原型的方法會再建立新物件(實例)時，不斷的重新創立，比較浪費記憶體空間。

```js {13}
function Person(name, job) {
  this.name = name;
  this.job = job;
  this.sayHi = function() {
    console.log('Hi! I am ' + this.name);
  };
}
let Amber = new Person('Amber', 'Nurse');
Amber.sayHi();
let Eason = new Person('Eason', 'Engineer');
Eason.sayHi();

console.log(Amber.sayHi === Eason.sayHi); // false
```

## 建構函數加原型鍊

這是目前比較常見的方式。在前一個方式，會造成原型的方法不斷的被創立，造成記憶體空間的浪費。所以利用原型鍊的概念，我們把方法掛在 Person 的原型上，這樣就可以避免每次創立物件就要再一次宣告新的方法了。

```js {15}
function Person(name, job) {
  this.name = name;
  this.job = job;
}

Person.prototype.sayHi = function() {
  console.log('Hi! I am ' + this.name);
};

let Amber = new Person('Amber', 'Nurse');
Amber.sayHi();
let Eason = new Person('Eason', 'Engineer');
Eason.sayHi();

console.log(Amber.sayHi === Eason.sayHi); // true
```
優點：解決了方法會不斷地被宣告的問題。

缺點：程式碼一龐大起來，其實並不好維護，方法可能會散落在各地，一不小心就會覆蓋到其他方法。

* 依照這個可以在原型上新增方法的概念，我們同時可以在內建的原型物件上寫上客製化的函數。

```js
Array.prototype.consoleAllItem = function () {
  this.forEach(function (item) {
    console.log(item);
  });
}

let newArray = ['Eason', 'Amber', 'Jason'];

newArray.consoleAllItem();

// Eason
// Amber
// Jason
```
但不建議這樣做，有時候會怕覆蓋到原本的方法。


## Object Create

這個函數可以指定其原型物件與屬性，創建一個新物件。

> Object.create(proto [, propertiesObject])

**參數：**
1. proto：新創建對象的原型物件。
2. propertiesObject：選填。要添加到新物件的可列舉（新添加的屬性是該新物件自身的屬性，而不是其原型鍊上的屬性）的屬性。

**回傳:**
具有指定原型與屬性的新物件。(若傳入不是 null 或物件，將會拋出 TypeError 例外)

::: tip
透過 Object.create() 可以建立一個空物件，同時可以將你帶入 Object.create() 的參數內容變成該物件的原型。
:::

```js
// 創造一個新的屬性
let Person = {
  name: 'Eason',
  sayHi: function () {
    console.log('Hi! I am ' + this.name);
  }
}

let person1 = Object.create(Person);

console.log(person1);
console.log(person1.name);  // Eason
person1.sayHi();            // Hi! I am Eason
```

![](https://i.imgur.com/SkDQX0h.png)

可以看到這邊用 Object.create <span style="color: #f5587b;">**繼承**</span> 了 Person 所有的屬性給 person1，進而創造新的物件。但這些屬性就變成 person1 他原型鍊上的屬性，並不是本身的屬性，這時候就要用到第二個參數。

```js
// 創造一個新的屬性
let Person = {
  name: 'Eason',
  sayHi: function () {
    console.log('Hi! I am ' + this.name);
  }
}

let person1 = Object.create(Person, {
  name: { 
    value: 'Amber'
  },
  job: { 
    value: 'engineer'
  },
});

console.log(person1);
console.log(person1.name);  // Amber
person1.sayHi();            // Hi! I am Amber
```
![](https://i.imgur.com/u5WS7VC.png)

可以看到說，使用第二個參數可以讓產生的新物件有本身的屬性，其中因為 name 因為自身有就不會到原型鍊上去尋找。

::: tip
其實使用 Object Create 這個方法的概念可以理解為繼承，他創造了新的空物件並把 \_\_proto\_\_ 指向指定的原型物件。
:::

### propertiesObject

在來我們來看看第二個參數的內容，他傳入的是一個物件，裡面是每個屬性的配置。這邊的配置與 [Object​.define​Properties()](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties)的 props 是相同的。


```js
// 創造一個新的屬性
let Person = {
  name: 'Eason',
  sayHi: function () {
    console.log('Hi! I am ' + this.name);
  }
}
// 因為本身有賦予 name 屬性 value，所以原型上的 name 就會被覆蓋。
let person1 = Object.create(Person, {
  name: { 
    value: 'Amber'
  }
});
```

#### 1. value

該屬性的值，可為任何 javascript 中的物件(number, object, function, etc)。預設為 undefined.

#### 2. writable

代表是否可覆寫。所謂的覆寫就是該屬性可以重新賦值，如果設置成 false 則任何想要修改該屬性的操作皆無效(但不會報錯)，預設為 false.

```js
{
  name: {
    value: 'Amber',
    writable: true
  }
}
```
```js
console.log(person1.name);
person1.name = 'Eason';
console.log(person1.name);

// Amber
// Eason
```

#### 3. get

若訪問該屬性，則會立刻回傳該屬性的值，必定要有回傳值，若有配置 get 則上一個 Value 屬性就不需要做配置，預設為 undefined。

```js
{
  name: {
    get: function() {
      console.log('執行 get 方法');
      return 'Amber';
    }
  }
}
```

```js

console.log(person1.name);

// 執行 get 方法
// Amber
```

#### 4. set

若該屬性被重新給予其他值，則會調用改方法。預設為 undefined.


::: tip
如果把 value 和 get/set 一起使用，系統會出現錯誤，原因在於 get/set 不能和 value並存，因此會把配置分為兩種，一個是利用 get()、set() 讓存取可以有較多變化，另一個是透過 value 或 writable 單純操作資料，兩者都可以和 enumerable、configurable 做搭配。
:::

#### 5. enumerable
 
是否能在 for-in 循環中歷遍出来或在 Object.keys 中列舉出来。預設為 false.

我們把 name 的屬性配置改為:

```js
{
  name: { 
    value: 'Amber',
    enumerable: true
  }
}
```
就可以在 for..in 找到該屬性

```js

for (var prop in person1) {
  console.log(prop + ':' + person1[prop]);
}

// name: Amber
// sayHi: function() {...} 
```


#### 6. configurable

是否可以重新在設定以上的配置，以上的屬性都可以在 Object​.define​Properties 種重新配置，但是 configurable 若是 false，以上的配置皆無效。

### 為什麼 Vue 要用 Object.create 來創建物件呢?

我們在 Vue 的原始碼都會看到，作者都使用 Object.create(null) 來初始化一個新的物件，但是為什麼不單純直接 { } 宣告就好了，這其實是有原因的。
先來看看 Object.create(null) 會回傳給我們什麼？

```js
let newObj = Object.create(null);
console.log(newObj);
```
![](https://i.imgur.com/r5Xlcjm.png)

一個非常乾淨的物件，連最基本的原型都沒有，沒有那些 Object 上的方法。在來看看 { } 創造的物件給我們什麼?

```js
let newObj = {};
console.log(newObj);
```
![](https://i.imgur.com/4RnFtDj.png)

可以發現就算指定空物件，javascript 會幫我們把該物件的原型指到 Object，這樣創造出來的物件都會有基本的物件方法。

::: tip
我們可以在乾淨的空物件上，定義屬於自己的方法，就不會怕不小心把原型鍊上的同名的方法蓋掉了。
:::

### 支援舊瀏覽器

有些舊的瀏覽器，其實是沒有 Object.create 這個方法的，我們可以自己寫一個簡單的函數來實現他。(只傳入一個參數)

```js
if(!Object.create){
    Object.create = function(o){
        if(arguments.length > 1){
            throw new Error('Object.create implementation' + ' only accepts the first parameter')
        }
        function F() {};
        function.prototype = o;
        return new F();
    };
}
```

> 在舊的瀏覽器新增新瀏覽器有的原生方法，稱為 Pollyfil。


## 結論
在專案中，大概最常用到的就是**建構函數加原型鍊**這個方式了，ES6 之後我們也很常會用到 Class 這個語法糖，原理都是藉由原型的方式來實現物件的創立、繼承由原型練的概念來實現等。這篇大概就是平常最常使用到建立物件原型的方式，其他想要知道的方法請參考底下的來源，畢竟在實務中很少用到。可以看上一篇文章，再來看這篇也會比較容易知道為什麼。下一篇就來好好的討論 ES6 Class 的方式來建立物件吧。


##### 來源：
1. [克服javascript](https://www.udemy.com/javascriptjs/learn/v4/content)
2. [JavaScript建立物件的七種方式全面總結](https://codertw.com/%E5%89%8D%E7%AB%AF%E9%96%8B%E7%99%BC/231599/)
3. [详解Object.create(null)](https://juejin.im/post/5acd8ced6fb9a028d444ee4e#heading-2)
3. [Object​.create()](https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Object/create)

