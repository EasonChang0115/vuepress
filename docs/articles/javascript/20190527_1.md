---
title: javascript 原型鍊與繼承
category: javascript
tags:
  - javascript
  - prototype
  - inheritance
description: 以前剛開始接觸 javascript 的時候，其實很少用到繼承或 new 運算子的相關概念，頂多就是對於畫面的 Dom 操作而已。但後來工作越來越複雜不簡單後，常常需要自己寫一個物件並對其做操作，也慢慢的理解 javascript 底層的運作。雖然 ES6 出現了新的語法糖，讓我們更好的去操作及創造物件，並用 Java 、C 等語言的思考來對物件做繼承處理，但萬變不離其宗，javascript 的繼承概念，還是原型鍊，理解原型鍊可以讓我們更好的除錯跟維護，也會更容易理解物件的 this 。
image: https://i.imgur.com/RPYNxYf.png
meta:
  - name: og:url
    content: https://easonchang0115.github.io/articles/javascript/20190516_1.html
  - name: og:title
    content: javascript Functional Programming
  - name: og:description
    content: 以前剛開始接觸 javascript 的時候，其實很少用到繼承或 new 運算子的相關概念，頂多就是對於畫面的 Dom 操作而已。但後來工作越來越複雜不簡單後，常常需要自己寫一個物件並對其做操作，也慢慢的理解 javascript 底層的運作。雖然 ES6 出現了新的語法糖，讓我們更好的去操作及創造物件，並用 Java 、C 等語言的思考來對物件做繼承處理，但萬變不離其宗，javascript 的繼承概念，還是原型鍊，理解原型鍊可以讓我們更好的除錯跟維護，也會更容易理解物件的 this 。
  - name: og:image
    content: https://easonchang0115.github.io/20190514_1.png
---

以前剛開始接觸 javascript 的時候，其實很少用到繼承或 new 運算子的相關概念，頂多就是對於畫面的 Dom 操作而已。但後來工作越來越複雜不簡單後，常常需要自己寫一個物件並對其做操作，也慢慢的理解 javascript 底層的運作。雖然 ES6 出現了新的語法糖，讓我們更好的去操作及創造物件，並用 Java 、C 等語言的思考來對物件做繼承處理，但萬變不離其宗，javascript 的繼承概念，還是原型鍊，理解原型鍊可以讓我們更好的除錯跟維護，也會更容易理解物件的 this 。

<!-- more -->

# javascript 原型鍊與繼承

Javascript 的跟其他的程式語言有很大的不同，而是採用原型的方式來實現[ 繼承(inheritance) ]這個概念的。在其他程式語言中，例如 Java 或 C++，都有 class 和 namespace 這些基本概念，用 new 創造出相對的 instance (物件實例)，每個物件都有私有和公有的屬性，而如果產生繼承，則用相應的語法就可以了。但這樣的機制在 javascript 上則完完全全不適用，你會說 javascript 在 ES6 之後有出 class 可以創造物件阿，那也只不過是語法糖而已，背後運作的原理還是所謂的原型繼承(prototypal inheritance)。

::: tip 
繼承可以分成兩種，一種是 classical inheritance，這種方式用在 C++ 或 JAVA 當中；另一種則是 JavaScript 所使用的，是屬於 prototypal inheritance。
:::

## Portotype 原型 

在 javascript 中，所有的物件都有 prototype 的屬性。這個屬性會參考到另一個物件，我們稱為 proto。這是會被當前物件參考到而且取用屬性和方法，所以這也是個物件，而且原型物件也有自己的 proto 可以繼續往上尋找。這樣一連串的尋找屬性或方法，稱為 Prototype Chain (原型鍊)，物件可以分享一樣的 Prototype。

![](https://i.imgur.com/qQRawVQ.jpg)

由圖片可以看出來，obj1 和 obj2 的 prototype 皆為 proto，所以 obj1 和 obj2 都可以取用 proto 的方法和屬性。而 proto 上面又會有 proto，所以 obj1 和 obj2 也可以取用更上面的 proto 的方法和屬性。

### 舉個例子

我們先定義建構函數(函數皆可以當作建構函數來使用，箭頭函數除外)。

```js
// 建構子
function Person(first, last, age, gender) {
  this.first = first;
  this.last = last;
  this.age = age;
  this.gender = gender;
};
```
接著建立物件實例：

```js
var person1 = new Person('Eason', 'Chang', 27, 'male');

console.log(person1);
```
![](https://i.imgur.com/inn9979.png)

可以從瀏覽器開發者介面看到，person1 原型物件上定義的成員，也就是 Person 建構函數裡的成員。但也會看其他方法，例如 watch、valueOf 等，同樣也是定義在 Person() 建構子原型物件之上的成員，進而組成了一個Object，圖片顯示了這個原型鍊的運作方式。

![](https://mdn.mozillademos.org/files/13891/MDN-Graphics-person-person-object-2.png)

當我們呼叫 person1 的 prototype 上或者更上面的方法時

```js
person1.valueOf()
```

1. 先檢查 person1 物件上是否有可用的 valueOf() 函式。
2. 其實沒有，所以接著檢查 person1 物件的原型物件 (Person) 上是否有可用的 valueOf() 函式。
3. 同樣沒有，所以再檢查 Person() 建構子的原型物件 (Object) 上是否有可用的 valueOf() 函式。這次有，所以就會呼叫。

::: tip
在原型鍊中的函式與屬性並不是從任一物件複製到另一個物件，而是如上述的，沿著該原型鍊向上存取而得。
:::

### __proto__

所有的物件裡面都會包含原型（prototype）這個物件，在 JavaScript 物件用__proto__這個屬性指向本身的原型物件。如同上面例子的原型鍊（prototype chain）的概念，如果在原本的物件中找不到指定的屬性名稱或方法時，就會進一步到__proto__這裡面來找。

當然我們也可以重新指定物件的__proto__，但真的不要這樣做就是了。
```js
var person = {
  firstname: 'Default',
  lastname: 'Default',
  getFullName: function(){
      return this.firstname + ' ' + this.lastname;
  }
}

var jason = {
  firstname: 'Jason',
  lastname: 'Chang'
}

//指定john物件的原型指向person 專案中千萬別這麼做。
jason.__proto__ = person;
console.log(jason.getFullName());
// jason chang


var jane = {
  firstname: 'jane'
}

jane.__proto__ = person;
console.log(jane.getFullName());
// jane Default

```

### Javascript 的所有東西都是物件、純值

```js
var a = {};
var b = function(){};
var c = [];
// 會回傳一個最基本的物件Object
a.__proto__;
// 會回傳一個最基本的空函數物件
b.__proto__;
// 會回傳一個最基本的物件Object
b.__proto__.__proto__;
// 會回傳一個最基本的陣列物件
c.__proto__;
// 會回傳一個最基本的物件Object
c.__proto__.__proto__;
```
Object，基本物件，所有東西的 proto 到最後都會得到基本物件。所以之前使用的 call()、apply()、bind()，都是依照原型鍊往上找到最基本的函數物件，所擁有的屬性或方法。
所以的陣列的基本方法(push、pop、map、length、.........)也是最原始的陣列物件中的方法。
而所有物件，包含函數物件、陣列物件的最基本的proto都是Object。

## Inheritance 繼承 
在 MDN 講到，在 javascript 中，「繼承」的物件並不會一併複製功能過來，而是透過原型鍊連接其所繼承的功能，亦即所謂的原型繼承 (Prototypal inheritance)。簡單來說繼承就是物件可以取用別的物件屬性及方法。
::: tip
物件之間的功能共享一般稱為「委託 (Delegation)」，即特定物件將功能委託至通用物件類型。「委託」其實比繼承更精確一點。因為「所繼承的功能」並不會複製到「進行繼承的物件」之上，卻是保留在通用物件之中。
:::

### Reflection && Extend
1. Reflection：An Object can look at itself,listing and changing its properties and methods.
```js
var person = {
    firstname: 'Default',
    lastname: 'Default',
    getFullName: function(){
        return this.firstname + ' ' + this.lastname;
    }
}

var jason = {
    firstname: 'Jason',
    lastname: 'Chang'
}

//指定john物件的原型指向person 專案中千萬別這麼做。
jason.__proto__ = person;
```
遍歷物件所有成員，屬性不只物件本身，還會到原型上找
```js
for (var prop in jason) {
    console.log(prop + ':' + jason[prop]);
}

// firstname: Jason
// lastname: Chang
//  getFullName: function(){ return this.firstname + ' ' + this.lastname;}

```

若要檢查是否屬於本身物件的屬性，可以用hasOwnProperty()
```js
for (var prop in jason) {
    if(jason.hasOwnProperty(prop)){
        console.log(prop + ':' + jason[prop]);
    }
}

// firstname: Jason
// lastname: Chang
```
2. Extend() Underscore.js的方法
可以把物件裡的屬性都新增到另一個物件中。
```js
var jim = {
    address: '1111 Main St.',
    getAddress: function(){
        return this.firstname + "'s address: " + this.address;
    }
}
var jane = {
    getFirstName: function(){
        return this.firstname;
    }
}

_.extend(jason,jim,jane);
console.log(jason);
//{firstname: "jason", lastname: "Chang", address: "1111 Main St.", getAddress: ƒ, getFirstName: ƒ} 
```
若新增的屬性跟本來的名稱相同，會覆蓋。可以看看extend()的實作過程，在underscore.js中。

##### 來源：
1. [克服javascript](https://www.udemy.com/javascriptjs/learn/v4/content)
2. [Java​Script 中的「繼承」](https://developer.mozilla.org/zh-TW/docs/Learn/JavaScript/Objects/Inheritance)
3. [Prototypes in JavaScript](https://hackernoon.com/prototypes-in-javascript-5bba2990e04b)
4. [从设计初衷解释 JavaScript 原型链](https://www.jianshu.com/p/a97863b59ef7)
5. [該來理解 JavaScript 的原型鍊了](https://blog.techbridge.cc/2017/04/22/javascript-prototype/)
6. [Javascript继承机制的设计思想](http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html)

