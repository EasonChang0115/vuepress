---
title: javascript 原型鍊與繼承
category: javascript
tags:
  - javascript
  - prototype
  - inheritance
description: 以前剛開始接觸 javascript 的時候，其實很少用到繼承或 new 運算子的相關概念，頂多就是對於畫面的 Dom 操作而已。但後來工作越來越複雜不簡單後，常常需要自己寫一個物件並對其做操作，也慢慢的理解 javascript 底層的運作。雖然 ES6 出現了新的語法糖，讓我們更好的去操作及創造物件，並用 Java 、C 等語言的思考來對物件做繼承處理，但萬變不離其宗，javascript 的繼承概念，還是原型鍊，理解原型鍊可以讓我們更好的除錯跟維護，也會更容易理解物件的 this 。
image: https://i.imgur.com/RPYNxYf.png
meta:
  - name: og:url
    content: https://easonchang0115.github.io/articles/javascript/20190516_1.html
  - name: og:title
    content: javascript Functional Programming
  - name: og:description
    content: 以前剛開始接觸 javascript 的時候，其實很少用到繼承或 new 運算子的相關概念，頂多就是對於畫面的 Dom 操作而已。但後來工作越來越複雜不簡單後，常常需要自己寫一個物件並對其做操作，也慢慢的理解 javascript 底層的運作。雖然 ES6 出現了新的語法糖，讓我們更好的去操作及創造物件，並用 Java 、C 等語言的思考來對物件做繼承處理，但萬變不離其宗，javascript 的繼承概念，還是原型鍊，理解原型鍊可以讓我們更好的除錯跟維護，也會更容易理解物件的 this 。
  - name: og:image
    content: https://easonchang0115.github.io/20190514_1.png
---

以前剛開始接觸 javascript 的時候，其實很少用到繼承或 new 運算子的相關概念，頂多就是對於畫面的 Dom 操作而已。但後來工作越來越複雜不簡單後，常常需要自己寫一個物件並對其做操作，也慢慢的理解 javascript 底層的運作。雖然 ES6 出現了新的語法糖，讓我們更好的去操作及創造物件，並用 Java 、C 等語言的思考來對物件做繼承處理，但萬變不離其宗，javascript 的繼承概念，還是原型鍊，理解原型鍊可以讓我們更好的除錯跟維護，也會更容易理解物件的 this 。

<!-- more -->

# javascript 原型鍊與繼承

Javascript 的跟其他的程式語言有很大的不同，而是採用原型的方式來實現[ 繼承(inheritance) ]這個概念的。在其他程式語言中，例如 Java 或 C++，都有 class 和 namespace 這些基本概念，用 new 創造出相對的 instance (物件實例)，每個物件都有私有和公有的屬性，而如果產生繼承，則用相應的語法就可以了。但這樣的機制在 javascript 上則完完全全不適用，你會說 javascript 在 ES6 之後有出 class 可以創造物件阿，那也只不過是語法糖而已，背後運作的原理還是所謂的原型繼承(prototypal inheritance)。

::: tip 
繼承可以分成兩種，一種是 classical inheritance，這種方式用在 C++ 或 JAVA 當中；另一種則是 JavaScript 所使用的，是屬於 prototypal inheritance。
:::

### Inheritance 繼承 
One Object gets access to the properties and methods of another object.物件可以取用別的物件屬性及方法。

### Portotype 原型 
在javascript中，所有的物件都有prototype的屬性。這個屬性會參考到另一個物件，我們稱為proto。這是會被Obj參考到而且取用屬性和方法的物件，所以這也是個物件，原型物件也有自己的proto。這樣一連串的尋找屬性或方法，稱為Prototype Chain，物件可以分享一樣的Prototype。
![](https://i.imgur.com/qQRawVQ.jpg)

```js
var person = {
    firstname: 'Default',
    lastname: 'Default',
    getFullName: function(){
        return this.firstname + ' ' + this.lastname;
    }
}

var jason = {
    firstname: 'Jason',
    lastname: 'Chang'
}

//指定john物件的原型指向person 專案中千萬別這麼做。
jason.__proto__ = person;
console.log(jason.getFullName());
// jason chang


var jane = {
    firstname: 'jane'
}

jane.__proto__ = person;
console.log(jane.getFullName());
// jane Default

```


### Javascript 的所有東西都是物件、純值

```js
var a = {};
var b = function(){};
var c = [];
// 會回傳一個最基本的物件Object
a.__proto__;
// 會回傳一個最基本的空函數物件
b.__proto__;
// 會回傳一個最基本的物件Object
b.__proto__.__proto__;
// 會回傳一個最基本的陣列物件
c.__proto__;
// 會回傳一個最基本的物件Object
c.__proto__.__proto__;
```
Object，基本物件，所有東西的proto到最後都會的到基本物件。所以之前使用的call()、apply()、bind()，都是依照原型鍊往上找到最基本的函數物件，所擁有的屬性或方法。
所以的陣列的基本方法(push、pop、map、length、.........)也是最原始的陣列物件中的方法。
而所有物件，包含函數物件、陣列物件的最基本的proto都是Object。


### Reflection && Extend
1. Reflection：An Object can look at itself,listing and changing its properties and methods.
```js
var person = {
    firstname: 'Default',
    lastname: 'Default',
    getFullName: function(){
        return this.firstname + ' ' + this.lastname;
    }
}

var jason = {
    firstname: 'Jason',
    lastname: 'Chang'
}

//指定john物件的原型指向person 專案中千萬別這麼做。
jason.__proto__ = person;
```
遍歷物件所有成員，屬性不只物件本身，還會到原型上找
```js
for (var prop in jason) {
    console.log(prop + ':' + jason[prop]);
}

// firstname: Jason
// lastname: Chang
//  getFullName: function(){ return this.firstname + ' ' + this.lastname;}

```

若要檢查是否屬於本身物件的屬性，可以用hasOwnProperty()
```js
for (var prop in jason) {
    if(jason.hasOwnProperty(prop)){
        console.log(prop + ':' + jason[prop]);
    }
}

// firstname: Jason
// lastname: Chang
```
2. Extend() Underscore.js的方法
可以把物件裡的屬性都新增到另一個物件中。
```js
var jim = {
    address: '1111 Main St.',
    getAddress: function(){
        return this.firstname + "'s address: " + this.address;
    }
}
var jane = {
    getFirstName: function(){
        return this.firstname;
    }
}

_.extend(jason,jim,jane);
console.log(jason);
//{firstname: "jason", lastname: "Chang", address: "1111 Main St.", getAddress: ƒ, getFirstName: ƒ} 
```
若新增的屬性跟本來的名稱相同，會覆蓋。可以看看extend()的實作過程，在underscore.js中。

##### 來源：
1. [克服javascript](https://www.udemy.com/javascriptjs/learn/v4/content)
2. [JavaScript深入之从原型到原型链](https://github.com/mqyqingfeng/Blog/blob/master/articles/%E6%B7%B1%E5%85%A5%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0/JavaScript%E6%B7%B1%E5%85%A5%E4%B9%8B%E4%BB%8E%E5%8E%9F%E5%9E%8B%E5%88%B0%E5%8E%9F%E5%9E%8B%E9%93%BE.md)
3. [Prototypes in JavaScript](https://hackernoon.com/prototypes-in-javascript-5bba2990e04b)
4. [从设计初衷解释 JavaScript 原型链](https://www.jianshu.com/p/a97863b59ef7)
5. [該來理解 JavaScript 的原型鍊了](https://blog.techbridge.cc/2017/04/22/javascript-prototype/)
6. [Javascript继承机制的设计思想](http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html)

