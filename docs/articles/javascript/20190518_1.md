---
title: javascript 函數重載、IIFE與Closure
category: javascript
tags:
  - javascript
  - Closure
  - IIFE
description: 函數重載，在其他高階語言，比如Ｃ語言，可以依照不同參數數量、型態等來使用不同函數，但在 javascript 中卻似乎不是這麼一回事。需多的 framework 都會採用 IIFE 立即執行函數來撰寫，好處就是可以不會跟其他 framework 互相污染。Closure 的概念也是到處都可以被討論的，這裡就來紀錄一下關於閉包常見的設計方式吧！！
image: https://images.unsplash.com/photo-1517694712202-14dd9538aa97?ixlib=rb-1.2.1&auto=format&fit=crop&w=1950&q=80
meta:
  - name: og:url
    content: https://easonchang0115.github.io/articles/javascript/20190516_1.html
  - name: og:title
    content: javascript 函數重載、IIFE與Closure
  - name: og:description
    content: 函數重載，在其他高階語言，比如Ｃ語言，可以依照不同參數數量、型態等來使用不同函數，但在 javascript 中卻似乎不是這麼一回事。需多的 framework 都會採用 IIFE 立即執行函數來撰寫，好處就是可以不會跟其他 framework 互相污染。Closure 的概念也是到處都可以被討論的，這裡就來紀錄一下關於閉包常見的設計方式吧！！
  - name: og:image
    content: https://easonchang0115.github.io/20190514_1.png
---

函數重載，在其他高階語言，比如Ｃ語言，可以依照不同參數數量、型態等來使用不同函數，但在 javascript 中卻似乎不是這麼一回事。需多的 framework 都會採用 IIFE 立即執行函數來撰寫，好處就是可以不會跟其他 framework 互相污染。Closure 的概念也是到處都可以被討論的，這裡就來紀錄一下關於閉包常見的設計方式吧！！

<!-- more -->

# javascript 函數重載、IIFE與Closure

## Function overloading 函數重載

在其他高階語言中，函數可以依傳入參數的不同數量、型態來使用同一個參數名稱但卻指向不同函數。但是在 javascript 中，函數即是物件，所以沒有這個處裡函數的功能。
但因為 js 的 function 為一等公民，還是有很多種方式來實現函數重載這個功能。

#### 用參數的方式來呼叫同一支函數。(預設情況)

```js
var greet = function (first, last, lang) {
    if(lang === 'en'){
        console.log('Hello ' + first + ' ' + 'last');
    }
    if(lang === 'tw'){
        console.log('你好 ' + first + ' ' + 'last');
    }
}
function greetEng(first, last){
    greet(first, last, 'en');
}
function greetTai(first, last){
    greet(first, last, 'tw');
}
greetEng('jason','chang');
greetTai('jason','chang');
```
這裡運用了函數參數值的判斷來，來執行不同的操作，當然也可以用參數的數量(arguments.length)來做依據。

#### 運用 arguments.length 參數的長度決定執行的操作

```js
function overloading () {
  switch (arguments.length === 1) {
    case 1: 
      console.log('一個參數的情形');
      break;
    case 2:
      console.log('兩個參數的情形');
      break;
  }
}
```
但是這種方式有個很大的缺點，只要參數一多起來，處理的情況就相對複雜很多。

#### 運用了閉包的原理來實現函數重載
因為比較複雜，這裡舉一個例子來說明。在這組陣列中，我們想要實現一個查找的方式，沒有輸入任何參數的時候，回傳全部人姓名 ; 傳入一個參數的時候，輸出和 first name 相同的人的姓名 ; 輸入兩個參數的時候，輸出 fitst name 和 last name 皆相同的姓名。

```js
var people = {
    values: ['jason chang', 'eason chang', 'jason hao', 'amber chu'];
};
```

然後希望用以下方式來實現為 people 這個物件進行重載

```js
// 不傳任何參數
addMethod(people, "find", function() {});

// 傳一個參數 希望能找到 first name 與參數相同的人
addMethod(people, "find", function(a) {});

// 傳兩個參數 希望能找到 全名與參數相同的人
addMethod(people, "find", function(a, b) {});
```
其實這個 addMethod 函數真的很難想出來，想出這個方式的人 (John Resig) 真的很厲害，就來看看他怎麼實現的吧！
第一個參數是綁定了想要實現的對象物件，第二個參數是方法的名稱，第三個參數才是真正要執行的函數。

```js
function addMethod(object, name, fn) {
　　var old = object[name];
　　object[name] = function() { 
　　　　if(fn.length === arguments.length) { 
　　　　　　return fn.apply(this, arguments);
　　　　} else if(typeof old === "function") {
　　　　　　return old.apply(this, arguments);
　　　　}
　　}
}
```
程式碼短短的看起來很簡單，但解釋起來有點複雜，一個一個慢慢來解釋，先來想想執行這個 addMethod會發生什麼事！！

0. 產生新的執行環境
1. 執行的時候會用一個 old 變數來存目前的 object[name] 的值。
2. 然後再給予 object[name] 新的值，也就是一個 function。
以下很重要
3. 這個給予的 function 做了兩個判斷，第一個判斷也就是當執行這個 function 時，會判斷傳入的參數數量是否等於 fn 的參數數量，若等於則直接執行 fn。<span style='color: #f5587b;'>注意：這邊產生了閉包讓每次執行 function 時都可以用到 fn 這個函數</span>
4. 若不相等，則在判斷剛剛存的 old 是否為函數，若是函數的話則執行。<span style='color: #f5587b;'>注意：這邊產生了閉包讓每次執行 function 時都可以用到 old 這個變數</span>
5. 執行環境結束，所以每次執行 addMethod 這個方法時，執行環境都會保存著自己的 fn 和 old（產生了 closure），方便 function 被呼叫時可以拿來使用。

接者我們就可以來試試看 addMethod 來實現函數重載的功能了

```js
addMethod(people, 'find', function() {
  return this.values;
});

addMethod(people, 'find', function(firstName) {
  return this.values.filter((value) => {
    return value.indexOf(firstName) !== -1 ? true : false;
  });
});

addMethod(people, 'find', function(firstName, lastName) {
  return this.values.filter((value) => {
    var fullName = `${firstName} ${lastName}`;
    return value.indexOf(fullName) !== -1 ? true : false;
  });
});

```
這邊就利用 addMethod 來給與 people.find() 這個方法函數重載的功能。每次執行的 addMethod 都會創造屬於自己的執行環境跟 closure，所以這邊總共產生了三個執行環境與三個對應的 closure。

```js
console.log(people.find());
console.log(people.find('jason'));
console.log(people.find('amber', 'chu'));

// jason chang, eason chang, jason hao, amber chu
// jason chang, jason hao
// amber chu
```

這邊要開始思考了，到底程式是怎麼跑的！！
::: tip
目前 people.find() 是接受兩個參數的。因為最後一次執行 addMethod 方法傳入的 callback 是一個兩個參數的 function。
:::


![](https://i.imgur.com/pSUKz9F.png)

* 每一個都代表一個執行環境
* 每次執行 people.find() 會先從最後一個執行環境開始
* 執行環境的順序不影響最後的結果，最終都會找到對應的 fn 來執行。



## IIFE (Immediately invoked function expression)立刻呼叫的函數表示式

利用()可以Invoke function的特性，我們可以在創造之後直接呼叫他。
如果你有一段程式碼，只被執行一次，或許就該考慮使用立即函式將程式碼包裹起來，這樣做有幾個好處。1.全域變數的減少：2.全域變數區域化：

```js
//函數陳述式 statesment
function greet(name){
    console.log('hello ' + name);
};
greet('Jason');

//函數表示式 Expression
var greetFunc = function(name){
    console.log('hello ' + name);
};
greetFunc('Jason');

// IIFE 1 變數指向，呼叫變數後就可以直接執行。
var IIFEfunc = function(name){
    console.log('hello ' + name);
}('jason');

console.log(IIFEfunc);

// IIFE 2 比較常見
(function(name){
    console.log('hello ' + name);
}('jason'));
```

## IIFE and safe code

```js

(function(name){
    var greeting = 'hello';
    console.log('hello ' + name);        
}('jason'));

```
全域執行環境被創造後，執行到IIFE，他會創造函數物件記憶體(匿名的)，直到程式執行到()後，知道這個函數要被invoke，因此他創造一個新的執行環境。IIFE裡面的變數(greeting)就會進到該執行環境的變數環境中，不是在全域，任何我宣告在函數內部的變數都不會接觸到全域環境。
我們可以將程式碼包在IIFE裡面，保證他不會和其他東西有衝突。
我們可以把全域物件當作參數丟到IIFE中，確保它可以使用。

```js
var globalValue = 'hi';
console.log(globalValue); //hi note: 這邊若不加分號 會噴錯

(function(global,name){
    var greeting = 'hello';
                       
    global.globalValue = 'IIFE changed: hi~hi~'; //影響全物物件
                       
    console.log('hello ' + name);        
}(window,'jason'));

console.log(globalValue) //IIFE changed: hi~hi~

```
## Closures 閉包
```js
function greet(whattosay){
    return function(name){
        console.log(whattosay + ' ' + name);
    };
};

var sayHi = greet("hi");
sayHi('Tony');
```
1. 當程式一開始執行，創造全域執行環境後，把greet function、sayHi放到記憶體中(hoist)等待執行。
2. 執行到greet("hi")會創造一個新的執行環境來跑greet("hi")這個function，回傳一個function給變數sayHi，並銷毀執行環境。
3. sayHi就會指到回傳的function(匿名)位置。
4. sayHi('Tony');創造新的執行環境跑這個function，可以看到說裡面有whattosay的變數，他會依scope chanin往上找
5. 即使greet函數的執行環境已經沒有了，sayHi的執行環境仍然可以參照到whattosay變數，在外部環境記憶體空間。

結論：
a. 即使外部環境已經執行結束，內部創造的函式仍然可以參照到他的記憶體位置。
b. javascript要確保函數可以再範圍鍊中找到他想要取得的變數。
c. 就像是執行環境把他的外部環境(參考的變數)給包住了，這個包住所有可以取用的變數的現象稱為閉包。

![](https://i.imgur.com/dwT4VMN.jpghttps://)


```js
function buildFunctions(){
    var arr = [];
    for(var i = 0;i < 3; i++){
        arr.push(function(){
            console.log(i)    
        });
    };
    return arr;
};

var fs = buildFunctions();

fs[0]();
fs[1]();
fs[2]();

```
以上會跑出什麼?
.
.
.
.
.
.
.
.


```js
// 3
// 3
// 3
```
1. push 的function沒有執行，他只是被宣告並指向arr陣列裡的元素。
2. 當arr[0]()被invoke，他會呼叫並執行。創造執行環境
3. arr[0]()有i這個變數，但是因為function裡面沒有，他會往外找(scope chain)，會找到變數i。
4. 但是i早已經跑完迴圈了，所以值變成了3。所以每個arr陣列裡的function都會抓到i = 3。
5. 記住，很重要的一點在push時，function並沒有執行。裡面的i是沒有被創造的。
![](https://i.imgur.com/kQ4vlXO.jpg)



如何讓它如我們想要的輸出1,2,3呢?

* 解法一: ES6 使用let
```js
function buildFunctions(){
    var arr = [];
    for(let i = 0;i < 3; i++){
        arr.push(function(){
            console.log(i)    
        });
    };
    return arr;
};

var fs = buildFunctions();

fs[0]();
fs[1]();
fs[2]();

```
使用let，他在每次的for迴圈都會重新指向新的記憶體位置。而push function裡面的i每次都是不同的位置。因此當呼叫時，就會指向該記憶體位置。(let i每次產生都會指向新的記憶體位置)

* 解法二: 使用IIFE
```js
function buildFunctions() {
    var arr = [];
    for (var i = 0; i < 3; i++) {
        arr.push(
            (function(j) {
                return function() {
                    console.log(j);
                };
            }(i)));
    };
    return arr;
};

var fs = buildFunctions();

fs[0]();
fs[1]();
fs[2]();

```
他會立刻執行並回傳新的function給arr陣列。當陣列元素被invoke的時候，他的執行環境的scope chain就會參照當時的IIFE的環境變數。這就是用執行環境去包住他讓他的值固定。
閉包的原理就是為了scope chain存在的。

## Closures 閉包應用 function factories

### function factories
利用閉包產生一個可以永久被使用的參數值。
```js
function makeGreeting(lang){
    return function(first,last){
        if(lang === 'en'){
            console.log('hello ' + first + ' ' + last);
        }
        if(lang === 'es'){
            console.log(`hola ${first} ${last}`);
        }
    }
}
var greetEnglish = makeGreeting('en');//產生閉包
var greetSpanish = makeGreeting('es');//產生閉包

greetEnglish('Jason','Chang');// hello Jason Chang
greetSpanish('Eason','Hao' );// hola Eason Hao
```
當回傳的函數被執行，若lang沒有宣告在函數裡面，他會依ScopeChain往外面找，參照的位置為上一層執行過後的變數記憶體位置。
* 回傳的function並沒有被執行，直到遇到()才會invoke。
* 執行function會產生執行環境並產生外部連結的參照，而外部連結的參照為宣告的記憶體位置的外層(詞彙環境)。
* 即是兩個回傳函數詞彙環境相同，在相同的makeGreeting()中，它們還是會指向不同的記憶體位置。因為他們在兩個不同的執行環境中被創造。不論呼叫多少次他都會產生新的記憶體空間，裡面宣告的function(ex: function(first,last))若有被回傳使用都會外部連結到這裡。

![](https://i.imgur.com/gZVIMTc.jpg)

#### callback function
A function you give to another function.To be run when the other function is finished.
So the function you call(i.e.invoke),'calls back'by calling the function you gave it when it finishes.


```js
function tellMeWhenDone(callback){
    var a = 1000; // do something
    var b = 2000; // somer work
    
    callback(); // the 'callback',it runs the function I gave it.
};

tellMeWhenDone(function(){
    console.log('I am done')
})

tellMeWhenDone(function(){
    console.log('I am done done')
})

//I am done
//I am done done

```
實際應用:
```js
function sayHiLater(){
    var greeting = 'hi';
    setTimeout(function(){
        console.log(greeting);
    },3000);
};
sayHiLater();
// 3秒後，印出hi

```
這邊就用到閉包及callback的觀念來處理了。
1. 在setTimeout中，我們使用函數表示式傳入函數當參數。
2. sayHiLater()執行完後，會到Event Queue看有沒有要執行的事件，發現有個function要在3秒後執行。(callback)
3. 3秒後，執行該function，創造執行環境並產生外部連結的參照指向已經執行完畢的sayHiLater()記憶體位置。
4. greeting變數因Scope Chain找到在sayHiLater()記憶體中。(閉包)

```js
// Jquery uses function expression and first-class function
$('button').click(fucntion(){});
```

##### 來源：
1. [克服javascript](https://www.udemy.com/javascriptjs/learn/v4/content)
1. [函數重載](https://www.cnblogs.com/yugege/p/5539020.html)

