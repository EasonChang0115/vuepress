(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{536:function(t,e,r){"use strict";r.r(e);var a=r(6),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("p",[t._v("剛開始學 React，被元件化的強大給吸引，和同事都會不斷地討論如何拆分的更細，職責更簡單。在一翻閱官方文件中，赫然看到合成事件，React 把事件都進行統一的管理，不像 Vue 是透過 proxy 去儲存對應的事件，一直以來我都是這樣想，直到認真看完原始碼跟其他部落客的分享後，才知道 React 對事件的處理已經演化到這樣的地步了。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://images.unsplash.com/photo-1497215728101-856f4ea42174?ixid=MnwxMjA3fDF8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&ixlib=rb-1.2.1&auto=format&fit=crop&w=1050&q=80",alt:""}})]),t._v(" "),r("p",[t._v("很多人都知道 React 的事件機制不是原生的，沒有綁定到 DOM 上，觸發的事件也是透過對原生事件進行包裝。")]),t._v(" "),r("p",[t._v("可以透過印出事件實例來看，他並不是原生的 event")]),t._v(" "),r("div",{staticClass:"language-javascript= line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("const handleButtonClick = (e) => {\n  console.log(e);\n};\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br")])]),r("p",[r("img",{attrs:{src:"https://i.imgur.com/qd277Nb.png",alt:""}})]),t._v(" "),r("p",[t._v("除兼容所有瀏覽器外，它還擁有和瀏覽器原生事件相同的接口(v17 之後)，包括 stopPropagation() 和 preventDefault()。")]),t._v(" "),r("h2",{attrs:{id:"什麼是合成事件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什麼是合成事件"}},[t._v("#")]),t._v(" 什麼是合成事件？")]),t._v(" "),r("p",[t._v("React 自己實現了事件註冊、儲存、冒泡、分配等邏輯，並且在 DOM 事件基礎上做了改進，以減少記憶體的消耗等，而這套機制被稱為合成事件。")]),t._v(" "),r("h2",{attrs:{id:"為什麼需要合成事件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#為什麼需要合成事件"}},[t._v("#")]),t._v(" 為什麼需要合成事件？")]),t._v(" "),r("p",[t._v("想想看，用 React 在使用的時候，什麼時候去管理事件的 remove 了，也很少去關心不同瀏覽器之間的實作，以及可以自定義事件等等。")]),t._v(" "),r("p",[t._v("合成事件替我們做到了：")]),t._v(" "),r("ol",[r("li",[r("p",[t._v("垃圾回收機制：統一管裡所有事件，當物件被釋放時，會去銷毀相關事件。")])]),t._v(" "),r("li",[r("p",[t._v("進行瀏覽器的兼容：透過事件委派或代理，試圖透過相關事件的模擬，來抹平瀏覽器的差異性。")])]),t._v(" "),r("li",[r("p",[t._v("事件流程優先序：透過管理事件，可以調整事件的優先級，比如渲染畫面頻繁的事件就會有比較高的權重。")])]),t._v(" "),r("li",[r("p",[t._v("自定義事件：透過合成，還可以自訂事件，例如 onChange 其實就是 React 本身對表單元件進行統一管理的自訂事件。")])])]),t._v(" "),r("p",[t._v("跨瀏覽器差異抹平真的相當重要，替開發者解決了很多不是業務邏輯上的問題。")]),t._v(" "),r("h2",{attrs:{id:"react-事件的綁定"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-事件的綁定"}},[t._v("#")]),t._v(" React 事件的綁定")]),t._v(" "),r("p",[t._v("自 React v17 版本後，事件會綁定到容器(root element)上進行代理，跟之前版本是綁到 doucment 。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/VqJpFla.png",alt:""}})]),t._v(" "),r("p",[t._v("當事件流冒泡到綁定的元件上時，才會一次觸發上面的事件。")]),t._v(" "),r("h3",{attrs:{id:"註冊事件代理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#註冊事件代理"}},[t._v("#")]),t._v(" 註冊事件代理")]),t._v(" "),r("p",[t._v("React 利用事件代理去捕獲瀏覽器的原生事件，接者會利用原生事件的 Event 對象去收集真實事件，然後調用真實事件。")]),t._v(" "),r("p",[t._v("在 v17 版本的 React，在創建初期就會調用 "),r("a",{attrs:{href:"https://github.com/facebook/react/blob/v17.0.0/packages/react-dom/src/client/ReactDOMRoot.js#L141",target:"_blank",rel:"noopener noreferrer"}},[t._v("listenToAllSupportedEvents"),r("OutboundLink")],1),t._v(" 方法，並在所有可以監聽的原生事件上添加監聽事件。")]),t._v(" "),r("h3",{attrs:{id:"指定事件處理"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#指定事件處理"}},[t._v("#")]),t._v(" 指定事件處理")]),t._v(" "),r("p",[t._v("說到事件處理，React 有把事件分成三種類型：")]),t._v(" "),r("ol",[r("li",[t._v("DiscreteEvent: blur、focus、click、submit、touchStart 等離散事件。")]),t._v(" "),r("li",[t._v("UserBlockingEvent: touchMove、mouseMove、scroll、drag、dragOver 等等，這些會影響使用者交互與畫面交互的事件。")]),t._v(" "),r("li",[t._v("ContinuousEvent: load、error、loadStart、abort、animationEnd 等，優先級最高，也就是說它們應該是立即同步執行的，這就是 Continuous 的意義，即可連續的執行，不被打斷.")])]),t._v(" "),r("p",[t._v("不同類型的事件對應到不同 listener，這邊的 "),r("a",{attrs:{href:"https://github.com/facebook/react/blob/89b610969d70d788f8c9769e3fa5b0044f5737ab/packages/react-dom/src/events/EventListener.js#L10",target:"_blank",rel:"noopener noreferrer"}},[t._v("listener"),r("OutboundLink")],1),t._v(" 是 React 統一分發事件的方法。")]),t._v(" "),r("p",[t._v("因為有三種類型的事件，listener 也有三種分發事件，統一處理事件程序：")]),t._v(" "),r("ol",[r("li",[t._v("dispatchDiscreteEvent")]),t._v(" "),r("li",[t._v("dispatchUserBlockingUpdate")]),t._v(" "),r("li",[t._v("dispatchEvent")])]),t._v(" "),r("p",[t._v("值得注意的是，dispatchDiscreteEvent 和 dispatchUserBlockingUpdate，主要是處理優先級的問題，底層還是靠 dispatchEvent 來執行事件分發。因此我們可以這樣認定，最後綁定到容器上面的統一分發事件的函數，就是 dispatchEvent。")]),t._v(" "),r("h2",{attrs:{id:"react-事件的觸發"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#react-事件的觸發"}},[t._v("#")]),t._v(" React 事件的觸發")]),t._v(" "),r("h3",{attrs:{id:"合成事件"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#合成事件"}},[t._v("#")]),t._v(" 合成事件")]),t._v(" "),r("p",[t._v("注意，到這邊以前都只是事件註冊跟分發而已，合成事件其實還沒有登場。當事件觸發後，就是執行上面提到的 dispatchEvent，並結合原生事件找到目標節點對應的虛擬 DOM 對象(這個階段會收集所有捕獲跟冒泡的節點)，執行對應函數，並將 "),r("a",{attrs:{href:"https://github.com/facebook/react/blob/v17.0.0/packages/react-dom/src/events/SyntheticEvent.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("SyntheticEvent"),r("OutboundLink")],1),t._v(" 傳入該函數。SyntheticEvent 最重要的地方就是針對不同瀏覽器做 Polyfill。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/evR4enl.png",alt:""}})]),t._v(" "),r("h3",{attrs:{id:"事件列隊"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#事件列隊"}},[t._v("#")]),t._v(" 事件列隊")]),t._v(" "),r("p",[t._v("dispatchEvent 之後，會把 "),r("a",{attrs:{href:"https://github.com/facebook/react/blob/v17.0.0/packages/react-dom/src/events/DOMPluginEventSystem.js#L233",target:"_blank",rel:"noopener noreferrer"}},[t._v("event 和 listener 放到一個 queue"),r("OutboundLink")],1),t._v(" 中。如果在全局綁定很多 onClick 事件，由於都是代理到容器頂部，所以合成事件(onClick)，只會創建一次，但會有很多 dispacthListeners，每一個都代表當前事件的 currentTarget。")]),t._v(" "),r("p",[r("img",{attrs:{src:"https://i.imgur.com/6sZDquC.png",alt:""}})]),t._v(" "),r("p",[t._v("最後調用完的 listener 會將 event.currentTarget 設為 null。")]),t._v(" "),r("h3",{attrs:{id:"版本差異"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#版本差異"}},[t._v("#")]),t._v(" 版本差異")]),t._v(" "),r("p",[t._v("要注意的是，v17 之後移除事件池(event pool)，主要的考量是事件在傳播過程中可以使用，但用完就會被回收，因而造成開發上的困擾，效能優化並不明顯，也有可能拖累其他效能("),r("a",{attrs:{href:"https://www.facebook.com/103934994422018/posts/201695671312616/",target:"_blank",rel:"noopener noreferrer"}},[t._v("參考"),r("OutboundLink")],1),t._v("、"),r("a",{attrs:{href:"https://reactjs.bootcss.com/docs/legacy-event-pooling.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("事件池"),r("OutboundLink")],1),t._v(")，在這之前的版本會有冒泡事件無法 stop 等問題，後來是透過模擬冒泡和捕獲而解決。React Native 還是有用事件池來管理事件的分配。")]),t._v(" "),r("h2",{attrs:{id:"結論"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#結論"}},[t._v("#")]),t._v(" 結論：")]),t._v(" "),r("p",[t._v("初淺的看過一遍原始碼，發現 React 團隊真的是一個很厲害的團隊，v16 和 v17 的功能雖然大同小異，但裡面針對合成事件的細節卻滿滿的不同。花幾天的時間，對於原始碼還只是稍微的小碰觸而已，也只看到冰山一角，希望透過學習這些強大團隊的程式架構，能讓我更加強大。")]),t._v(" "),r("h4",{attrs:{id:"參考資"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#參考資"}},[t._v("#")]),t._v(" 參考資")]),t._v(" "),r("p",[r("a",{attrs:{href:"https://www.readfog.com/a/1634367755893444608",target:"_blank",rel:"noopener noreferrer"}},[t._v("「React 進階」一文喫透 react 事件原理"),r("OutboundLink")],1),t._v(" "),r("a",{attrs:{href:"http://www.ayqy.net/blog/dive-into-react-fiber/",target:"_blank",rel:"noopener noreferrer"}},[t._v("完全理解 React Fiber"),r("OutboundLink")],1),t._v(" "),r("a",{attrs:{href:"https://reactjs.bootcss.com/docs/events.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("合成事件"),r("OutboundLink")],1),t._v(" "),r("a",{attrs:{href:"https://github.com/facebook/react/blob/75ab53b9e1de662121e68dabb010655943d28d11/packages/events/SyntheticEvent.js#L62",target:"_blank",rel:"noopener noreferrer"}},[t._v("SyntheticEvent"),r("OutboundLink")],1),t._v(" "),r("a",{attrs:{href:"https://juejin.cn/post/6844903905382367245",target:"_blank",rel:"noopener noreferrer"}},[t._v("谈谈 React 事件机制和未来"),r("OutboundLink")],1),t._v(" "),r("a",{attrs:{href:"https://segmentfault.com/a/1190000039108951",target:"_blank",rel:"noopener noreferrer"}},[t._v("为什么要自己实现一套事件机制"),r("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=s.exports}}]);